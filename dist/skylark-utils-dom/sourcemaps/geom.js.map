{"version":3,"sources":["geom.js"],"names":["define","dom","langx","noder","styler","scrollbarWidth","undefined","cachedScrollbarWidth","w1","w2","div","createFragment","innerDiv","childNodes","append","document","body","offsetWidth","css","clientWidth","remove","borderExtents","elm","isWindow","left","top","right","bottom","s","getComputedStyle","px","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","boundingPosition","coords","rootNodeRE","test","nodeName","getBoundingClientRect","parent","offsetParent","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","clientHeight","value","clientSize","height","dimension","width","isBorderBox","props","bex","pex","paddingExtents","contentRect","cs","getDocumentSize","doc","documentElement","max","Math","scrollWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","marginRect","obj","relativeRect","me","marginSize","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","window","pageXOffset","pageYOffset","pageRect","round","offset","scrollIntoView","align","getOffset","rootElm","x","y","nodeType","offsetLeft","offsetTop","parentWidth","parentHeight","parentElm","parentNode","pos","scrollLeft","scrollTop","hasScrollLeft","scrollTo","scrollY","hasScrollTop","scrollX","innerWidth","innerHeight","isDocument","geom","toPixel","mixin","getOffsets","offsets","parseFloat","rpercent","parseCss","element","property","parseInt","getDimensions","raw","preventDefault","pageY","pageX","getScrollInfo","within","overflowX","overflowY","hasOverflowX","hasOverflowY","getWithinInfo","withinElement","hasOffset","msize","posit","options","extend","atOffset","targetWidth","targetHeight","targetOffset","basePosition","dimensions","target","of","scrollInfo","collision","split","at","each","horizontalOffset","verticalOffset","length","rhorizontal","concat","rvertical","roffset","exec","rposition","elem","collisionPosition","using","elemWidth","elemHeight","collisionWidth","collisionHeight","position","myOffset","my","i","dir","positions","feedback","horizontal","vertical","abs","important","call","fit","data","newOverRight","withinOffset","outerWidth","collisionPosLeft","overLeft","overRight","newOverBottom","outerHeight","collisionPosTop","overTop","overBottom","flip","newOverLeft","newOverTop","flipfit","apply","arguments"],"mappings":"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","file":"../geom.js","sourcesContent":["define([\r\n    \"./dom\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./styler\"\r\n], function(dom, langx, noder, styler) {\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n    //viewport coordinate\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            return elm.getBoundingClientRect()\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = size(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left\r\n            }\r\n        } else {\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            }\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        height: height,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect: marginRect,\r\n\r\n        marginSize: marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        size: size,\r\n\r\n        width: width\r\n    });\r\n\r\n    ( function() {\r\n        var max = Math.max,\r\n            abs = Math.abs,\r\n            rhorizontal = /left|center|right/,\r\n            rvertical = /top|center|bottom/,\r\n            roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n            rposition = /^\\w+/,\r\n            rpercent = /%$/;\r\n\r\n        function getOffsets( offsets, width, height ) {\r\n            return [\r\n                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n            ];\r\n        }\r\n\r\n        function parseCss( element, property ) {\r\n            return parseInt( styler.css( element, property ), 10 ) || 0;\r\n        }\r\n\r\n        function getDimensions( raw ) {\r\n            if ( raw.nodeType === 9 ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { top: 0, left: 0 }\r\n                };\r\n            }\r\n            if ( noder.isWindow( raw ) ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { \r\n                        top: scrollTop(raw), \r\n                        left: scrollLeft(raw) \r\n                    }\r\n                };\r\n            }\r\n            if ( raw.preventDefault ) {\r\n                return {\r\n                    size : {\r\n                        width: 0,\r\n                        height: 0\r\n                    },\r\n                    offset: { \r\n                        top: raw.pageY, \r\n                        left: raw.pageX \r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                size: size(raw),\r\n                offset: pagePosition(raw)\r\n            };\r\n        }\r\n\r\n        function getScrollInfo( within ) {\r\n            var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-x\" ),\r\n                overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-y\" ),\r\n                hasOverflowX = overflowX === \"scroll\" ||\r\n                    ( overflowX === \"auto\" && within.width < scrollWidth(within.element) ),\r\n                hasOverflowY = overflowY === \"scroll\" ||\r\n                    ( overflowY === \"auto\" && within.height < scrollHeight(within.element));\r\n            return {\r\n                width: hasOverflowY ? scrollbarWidth() : 0,\r\n                height: hasOverflowX ? scrollbarWidth() : 0\r\n            };\r\n        }\r\n\r\n        function getWithinInfo( element ) {\r\n            var withinElement = element || window,\r\n                isWindow = noder.isWindow( withinElement),\r\n                isDocument = !!withinElement && withinElement.nodeType === 9,\r\n                hasOffset = !isWindow && !isDocument,\r\n                msize = marginSize(withinElement);\r\n            return {\r\n                element: withinElement,\r\n                isWindow: isWindow,\r\n                isDocument: isDocument,\r\n                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },\r\n                scrollLeft: scrollLeft(withinElement),\r\n                scrollTop: scrollTop(withinElement),\r\n                width: msize.width,\r\n                height: msize.height\r\n            };\r\n        }\r\n\r\n        function posit(elm,options ) {\r\n            // Make a copy, we don't want to modify arguments\r\n            options = langx.extend( {}, options );\r\n\r\n            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n                target = options.of,\r\n                within = getWithinInfo( options.within ),\r\n                scrollInfo = getScrollInfo( within ),\r\n                collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n                offsets = {};\r\n\r\n            dimensions = getDimensions( target );\r\n            if ( target.preventDefault ) {\r\n\r\n                // Force left top to allow flipping\r\n                options.at = \"left top\";\r\n            }\r\n            targetWidth = dimensions.size.width;\r\n            targetHeight = dimensions.size.height;\r\n            targetOffset = dimensions.offset;\r\n\r\n            // Clone to reuse original targetOffset later\r\n            basePosition = langx.extend( {}, targetOffset );\r\n\r\n            // Force my and at to have valid horizontal and vertical positions\r\n            // if a value is missing or invalid, it will be converted to center\r\n            langx.each( [ \"my\", \"at\" ], function() {\r\n                var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                    horizontalOffset,\r\n                    verticalOffset;\r\n\r\n                if ( pos.length === 1 ) {\r\n                    pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                        pos.concat( [ \"center\" ] ) :\r\n                        rvertical.test( pos[ 0 ] ) ?\r\n                            [ \"center\" ].concat( pos ) :\r\n                            [ \"center\", \"center\" ];\r\n                }\r\n                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n                // Calculate offsets\r\n                horizontalOffset = roffset.exec( pos[ 0 ] );\r\n                verticalOffset = roffset.exec( pos[ 1 ] );\r\n                offsets[ this ] = [\r\n                    horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                    verticalOffset ? verticalOffset[ 0 ] : 0\r\n                ];\r\n\r\n                // Reduce to just the positions without the offsets\r\n                options[ this ] = [\r\n                    rposition.exec( pos[ 0 ] )[ 0 ],\r\n                    rposition.exec( pos[ 1 ] )[ 0 ]\r\n                ];\r\n            } );\r\n\r\n            // Normalize collision option\r\n            if ( collision.length === 1 ) {\r\n                collision[ 1 ] = collision[ 0 ];\r\n            }\r\n\r\n            if ( options.at[ 0 ] === \"right\" ) {\r\n                basePosition.left += targetWidth;\r\n            } else if ( options.at[ 0 ] === \"center\" ) {\r\n                basePosition.left += targetWidth / 2;\r\n            }\r\n\r\n            if ( options.at[ 1 ] === \"bottom\" ) {\r\n                basePosition.top += targetHeight;\r\n            } else if ( options.at[ 1 ] === \"center\" ) {\r\n                basePosition.top += targetHeight / 2;\r\n            }\r\n\r\n            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n            basePosition.left += atOffset[ 0 ];\r\n            basePosition.top += atOffset[ 1 ];\r\n\r\n            return ( function(elem) {\r\n                var collisionPosition, using,\r\n                    msize = marginSize(elem),\r\n                    elemWidth = msize.width,\r\n                    elemHeight = msize.height,\r\n                    marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                    marginTop = parseCss( elem, \"marginTop\" ),\r\n                    collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                        scrollInfo.width,\r\n                    collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                        scrollInfo.height,\r\n                    position = langx.extend( {}, basePosition ),\r\n                    myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n                if ( options.my[ 0 ] === \"right\" ) {\r\n                    position.left -= elemWidth;\r\n                } else if ( options.my[ 0 ] === \"center\" ) {\r\n                    position.left -= elemWidth / 2;\r\n                }\r\n\r\n                if ( options.my[ 1 ] === \"bottom\" ) {\r\n                    position.top -= elemHeight;\r\n                } else if ( options.my[ 1 ] === \"center\" ) {\r\n                    position.top -= elemHeight / 2;\r\n                }\r\n\r\n                position.left += myOffset[ 0 ];\r\n                position.top += myOffset[ 1 ];\r\n\r\n                collisionPosition = {\r\n                    marginLeft: marginLeft,\r\n                    marginTop: marginTop\r\n                };\r\n\r\n                langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                    if ( positions[ collision[ i ] ] ) {\r\n                        positions[ collision[ i ] ][ dir ]( position, {\r\n                            targetWidth: targetWidth,\r\n                            targetHeight: targetHeight,\r\n                            elemWidth: elemWidth,\r\n                            elemHeight: elemHeight,\r\n                            collisionPosition: collisionPosition,\r\n                            collisionWidth: collisionWidth,\r\n                            collisionHeight: collisionHeight,\r\n                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                            my: options.my,\r\n                            at: options.at,\r\n                            within: within,\r\n                            elem: elem\r\n                        } );\r\n                    }\r\n                } );\r\n\r\n                if ( options.using ) {\r\n\r\n                    // Adds feedback as second argument to using callback, if present\r\n                    using = function( props ) {\r\n                        var left = targetOffset.left - position.left,\r\n                            right = left + targetWidth - elemWidth,\r\n                            top = targetOffset.top - position.top,\r\n                            bottom = top + targetHeight - elemHeight,\r\n                            feedback = {\r\n                                target: {\r\n                                    element: target,\r\n                                    left: targetOffset.left,\r\n                                    top: targetOffset.top,\r\n                                    width: targetWidth,\r\n                                    height: targetHeight\r\n                                },\r\n                                element: {\r\n                                    element: elem,\r\n                                    left: position.left,\r\n                                    top: position.top,\r\n                                    width: elemWidth,\r\n                                    height: elemHeight\r\n                                },\r\n                                horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                                vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                            };\r\n                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                            feedback.horizontal = \"center\";\r\n                        }\r\n                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                            feedback.vertical = \"middle\";\r\n                        }\r\n                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                            feedback.important = \"horizontal\";\r\n                        } else {\r\n                            feedback.important = \"vertical\";\r\n                        }\r\n                        options.using.call( this, props, feedback );\r\n                    };\r\n                }\r\n\r\n                pagePosition(elem, langx.extend( position, { using: using } ));\r\n            })(elm);\r\n        }\r\n\r\n        var positions = {\r\n            fit: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        outerWidth = within.width,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = withinOffset - collisionPosLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                        newOverRight;\r\n\r\n                    // Element is wider than within\r\n                    if ( data.collisionWidth > outerWidth ) {\r\n\r\n                        // Element is initially over the left side of within\r\n                        if ( overLeft > 0 && overRight <= 0 ) {\r\n                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                                withinOffset;\r\n                            position.left += overLeft - newOverRight;\r\n\r\n                        // Element is initially over right side of within\r\n                        } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                            position.left = withinOffset;\r\n\r\n                        // Element is initially over both left and right sides of within\r\n                        } else {\r\n                            if ( overLeft > overRight ) {\r\n                                position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                            } else {\r\n                                position.left = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far left -> align with left edge\r\n                    } else if ( overLeft > 0 ) {\r\n                        position.left += overLeft;\r\n\r\n                    // Too far right -> align with right edge\r\n                    } else if ( overRight > 0 ) {\r\n                        position.left -= overRight;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.left = max( position.left - collisionPosLeft, position.left );\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        outerHeight = data.within.height,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = withinOffset - collisionPosTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                        newOverBottom;\r\n\r\n                    // Element is taller than within\r\n                    if ( data.collisionHeight > outerHeight ) {\r\n\r\n                        // Element is initially over the top of within\r\n                        if ( overTop > 0 && overBottom <= 0 ) {\r\n                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                                withinOffset;\r\n                            position.top += overTop - newOverBottom;\r\n\r\n                        // Element is initially over bottom of within\r\n                        } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                            position.top = withinOffset;\r\n\r\n                        // Element is initially over both top and bottom of within\r\n                        } else {\r\n                            if ( overTop > overBottom ) {\r\n                                position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                            } else {\r\n                                position.top = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far up -> align with top\r\n                    } else if ( overTop > 0 ) {\r\n                        position.top += overTop;\r\n\r\n                    // Too far down -> align with bottom edge\r\n                    } else if ( overBottom > 0 ) {\r\n                        position.top -= overBottom;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.top = max( position.top - collisionPosTop, position.top );\r\n                    }\r\n                }\r\n            },\r\n            flip: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.left + within.scrollLeft,\r\n                        outerWidth = within.width,\r\n                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = collisionPosLeft - offsetLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                        myOffset = data.my[ 0 ] === \"left\" ?\r\n                            -data.elemWidth :\r\n                            data.my[ 0 ] === \"right\" ?\r\n                                data.elemWidth :\r\n                                0,\r\n                        atOffset = data.at[ 0 ] === \"left\" ?\r\n                            data.targetWidth :\r\n                            data.at[ 0 ] === \"right\" ?\r\n                                -data.targetWidth :\r\n                                0,\r\n                        offset = -2 * data.offset[ 0 ],\r\n                        newOverRight,\r\n                        newOverLeft;\r\n\r\n                    if ( overLeft < 0 ) {\r\n                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                            outerWidth - withinOffset;\r\n                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overRight > 0 ) {\r\n                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                            atOffset + offset - offsetLeft;\r\n                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.top + within.scrollTop,\r\n                        outerHeight = within.height,\r\n                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = collisionPosTop - offsetTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                        top = data.my[ 1 ] === \"top\",\r\n                        myOffset = top ?\r\n                            -data.elemHeight :\r\n                            data.my[ 1 ] === \"bottom\" ?\r\n                                data.elemHeight :\r\n                                0,\r\n                        atOffset = data.at[ 1 ] === \"top\" ?\r\n                            data.targetHeight :\r\n                            data.at[ 1 ] === \"bottom\" ?\r\n                                -data.targetHeight :\r\n                                0,\r\n                        offset = -2 * data.offset[ 1 ],\r\n                        newOverTop,\r\n                        newOverBottom;\r\n                    if ( overTop < 0 ) {\r\n                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                            outerHeight - withinOffset;\r\n                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overBottom > 0 ) {\r\n                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                            offset - offsetTop;\r\n                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            flipfit: {\r\n                left: function() {\r\n                    positions.flip.left.apply( this, arguments );\r\n                    positions.fit.left.apply( this, arguments );\r\n                },\r\n                top: function() {\r\n                    positions.flip.top.apply( this, arguments );\r\n                    positions.fit.top.apply( this, arguments );\r\n                }\r\n            }\r\n        };\r\n\r\n        geom.posit = posit;\r\n    })();\r\n\r\n    return dom.geom = geom;\r\n});"]}