{"version":3,"sources":["plugins.js"],"names":["define","dom","langx","noder","datax","eventer","finder","geom","styler","fx","$","elmx","register","pluginKlass","shortcut","name","prototype","pluginName","pluginKlasses","partial","fn","options","args","slice","call","arguments","unshift","this","plugin","apply","instantiate","elm","pluginInstance","data","isMethodCall","methodName","isFunction","charAt","error","length","mixin","concat","option","plugins","Array","Plugin","Evented","inherit","klassName","_construct","_elm","_initOptions","ctor","constructor","cache","defaults","ctors","superclass","i","hasOwnProperty","Object","defineProperty","value","destroy","_destroy","removeData","noop","_delay","handler","delay","handlerProxy","instance","setTimeout","key","parts","curOption","split","shift","pop","undefined","_setOptions","_setOption","self","returnValue","each","domNode"],"mappings":"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","file":"../plugins.js","sourcesContent":["define([\r\n    \"./dom\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./datax\",\r\n    \"./eventer\",\r\n    \"./finder\",\r\n    \"./geom\",\r\n    \"./styler\",\r\n    \"./fx\",\r\n    \"./query\",\r\n    \"./elmx\"\r\n], function(dom, langx, noder, datax, eventer, finder, geom, styler, fx, $, elmx) {\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice,\r\n        concat = Array.prototype.concat,\r\n        pluginKlasses = {};\r\n\r\n\r\n    /*\r\n     * Register a plugin type\r\n     */\r\n    function register( pluginKlass,shortcut) {\r\n        var name = pluginKlass.prototype.pluginName;\r\n        \r\n        pluginKlasses[name] = pluginKlass;\r\n\r\n        if (shortcut) {\r\n            elmx.partial(shortcut,$.fn[shortcut] = function(options) {\r\n                var args = slice.call(arguments,0);\r\n                args.unshift(name);\r\n                return this.plugin.apply(this,args);\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Create or get a plugin instance assocated with the element,\r\n     * also you can execute the plugin method directory;\r\n     */\r\n    function instantiate(elm,pluginName,options) {\r\n\r\n        var pluginInstance = datax.data( elm, pluginName );\r\n\r\n        if (options === \"instance\") {\r\n            return pluginInstance;\r\n        }\r\n\r\n        var isMethodCall = typeof options === \"string\",\r\n            args = slice.call( arguments, 2 ),\r\n            returnValue = this;\r\n\r\n        if ( isMethodCall ) {\r\n            var methodName = options;\r\n\r\n            if ( !pluginInstance ) {\r\n                return langx.error( \"cannot call methods on \" + pluginName +\r\n                    \" prior to initialization; \" +\r\n                    \"attempted to call method '\" + methodName + \"'\" );\r\n            }\r\n\r\n            if ( !langx.isFunction( pluginInstance[ methodName ] ) || methodName.charAt( 0 ) === \"_\" ) {\r\n                return langx.error( \"no such method '\" + methodName + \"' for \" + pluginName +\r\n                    \" plugin instance\" );\r\n            }\r\n\r\n            return pluginInstance[ methodName ].apply( pluginInstance, args );\r\n\r\n        } else {\r\n            // Allow multiple hashes to be passed on init\r\n            if ( args.length ) {\r\n                options = langx.mixin.apply( langx, [{},options ].concat( args ) );\r\n            }\r\n\r\n            if ( pluginInstance ) {\r\n                pluginInstance.option( options || {} );\r\n            } else {\r\n                var pluginKlass = pluginKlasses[pluginName]; \r\n                pluginInstance = new pluginKlass(elm,options);\r\n                datax.data( elm, pluginName,pluginInstance );\r\n            }\r\n            return pluginInstance;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    var Plugin =   langx.Evented.inherit({\r\n        klassName: \"Plugin\",\r\n\r\n        _construct : function(elm,options) {\r\n           this._elm = elm;\r\n           this._initOptions(options);\r\n        },\r\n\r\n        _initOptions : function(options) {\r\n          var ctor = this.constructor,\r\n              cache = ctor.cache = ctor.cache || {},\r\n              defaults = cache.defaults;\r\n          if (!defaults) {\r\n            var  ctors = [];\r\n            do {\r\n              ctors.unshift(ctor);\r\n              if (ctor === Plugin) {\r\n                break;\r\n              }\r\n              ctor = ctor.superclass;\r\n            } while (ctor);\r\n\r\n            defaults = cache.defaults = {};\r\n            for (var i=0;i<ctors.length;i++) {\r\n              ctor = ctors[i];\r\n              if (ctor.prototype.hasOwnProperty(\"options\")) {\r\n                langx.mixin(defaults,ctor.prototype.options);\r\n              }\r\n              if (ctor.hasOwnProperty(\"options\")) {\r\n                langx.mixin(defaults,ctor.options);\r\n              }\r\n            }\r\n          }\r\n          Object.defineProperty(this,\"options\",{\r\n            value :langx.mixin({},defaults,options)\r\n          });\r\n\r\n          //return this.options = langx.mixin({},defaults,options);\r\n          return this.options;\r\n        },\r\n\r\n\r\n        destroy: function() {\r\n            var that = this;\r\n\r\n            this._destroy();\r\n            // We can probably remove the unbind calls in 2.0\r\n            // all event bindings should go through this._on()\r\n            datax.removeData(this._elm,this.pluginName );\r\n        },\r\n\r\n        _destroy: langx.noop,\r\n\r\n        _delay: function( handler, delay ) {\r\n            function handlerProxy() {\r\n                return ( typeof handler === \"string\" ? instance[ handler ] : handler )\r\n                    .apply( instance, arguments );\r\n            }\r\n            var instance = this;\r\n            return setTimeout( handlerProxy, delay || 0 );\r\n        },\r\n\r\n        option: function( key, value ) {\r\n            var options = key;\r\n            var parts;\r\n            var curOption;\r\n            var i;\r\n\r\n            if ( arguments.length === 0 ) {\r\n\r\n                // Don't return a reference to the internal hash\r\n                return langx.mixin( {}, this.options );\r\n            }\r\n\r\n            if ( typeof key === \"string\" ) {\r\n\r\n                // Handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\r\n                options = {};\r\n                parts = key.split( \".\" );\r\n                key = parts.shift();\r\n                if ( parts.length ) {\r\n                    curOption = options[ key ] = langx.mixin( {}, this.options[ key ] );\r\n                    for ( i = 0; i < parts.length - 1; i++ ) {\r\n                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\r\n                        curOption = curOption[ parts[ i ] ];\r\n                    }\r\n                    key = parts.pop();\r\n                    if ( arguments.length === 1 ) {\r\n                        return curOption[ key ] === undefined ? null : curOption[ key ];\r\n                    }\r\n                    curOption[ key ] = value;\r\n                } else {\r\n                    if ( arguments.length === 1 ) {\r\n                        return this.options[ key ] === undefined ? null : this.options[ key ];\r\n                    }\r\n                    options[ key ] = value;\r\n                }\r\n            }\r\n\r\n            this._setOptions( options );\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOptions: function( options ) {\r\n            var key;\r\n\r\n            for ( key in options ) {\r\n                this._setOption( key, options[ key ] );\r\n            }\r\n\r\n            return this;\r\n        },\r\n\r\n        _setOption: function( key, value ) {\r\n\r\n            this.options[ key ] = value;\r\n\r\n            return this;\r\n        }\r\n\r\n    });\r\n\r\n    $.fn.plugin = function(name,options) {\r\n        var args = slice.call( arguments, 1 ),\r\n            self = this,\r\n            returnValue = this;\r\n\r\n        this.each(function(){\r\n            returnValue = instantiate.apply(self,[this,name].concat(args));\r\n        });\r\n        return returnValue;\r\n    };\r\n\r\n    elmx.partial(\"plugin\",function(name,options) {\r\n        var args = slice.call( arguments, 1 );\r\n        return instantiate.apply(this,[this.domNode,name].concat(args));\r\n    }); \r\n\r\n\r\n    function plugins() {\r\n        return plugins;\r\n    }\r\n     \r\n    langx.mixin(plugins, {\r\n        instantiate : instantiate,\r\n        \r\n        Plugin : Plugin,\r\n\r\n        register : register\r\n\r\n    });\r\n\r\n    return plugins;\r\n});"]}